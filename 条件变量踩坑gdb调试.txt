踩坑：
    1.死锁
        现象：
            可重入锁的在内层同步块进行wait操作导致无法释放锁资源
            手动修改mutex.__lock.__count=1可以让wait释放出锁资源
        解决方式：
            条件变量尽量在最外层的同步代码块使用
        原因：
            posix环境下，内层同步代码块中的wait操作无法释放锁，仅将计数减一
            java中相同逻辑代码不会造成死锁，await操作保证了即使在最内层也能释放锁资源
        结论：
            总之在posix中递归锁如果lock多次，wait操作是无法释放掉锁的


1.lock信息
    print lock
    $1 = {
        __data = {
            __lock = 1,         //锁持有状态 0-未加锁 1-已加锁 2-mutex被某个线程持有并且有另外的线程在等待它的释放
            __count = 1,        //锁持有计数
            __owner = 40409,    //锁持有者，线程id
            __nusers = 1,       //用于记录多少个线程持有该互斥锁，用于读写锁场景
            __kind = 1,         //锁类型：1-PTHREAD_MUTEX_RECURSIVE 0-普通锁
            __spins = 0,        //自旋锁的自旋次数
            __elision = 0,      //elision技术
            __list = {          //等待队列
                __prev = 0x0,
                __next = 0x0
            }
        },
        __size = {1 '\001', 0 '\000', 0 '\000', 0 '\000', 1 '\001', 0 '\000', 0 '\000', 0 '\000', -39 '\331', -99 '\235', 0 '\000', 0 '\000', 1 '\001', 0 '\000', 0 '\000', 0 '\000', 1 '\001', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000'},
        __align = 4294967297
    }

2.条件变量信息
    print cond
    $2 = {
        __data = {
            __wseq = {              //等待序列号，跟踪等待操作的顺序，从0开始原子递增
                __value64 = 0,      // 64位的单调递增序列号，用于唯一标识每个等待操作,为条件变量上的每个等待操作提供一个唯一的类时间戳
                __value32 = {
                    __low = 0,
                    __high = 0
                }
            },
            __g1_start = {          //G1组开始序列号，用于管理G1和G2的切换
                __value64 = 0,      // 当调用 pthread_cond_broadcast() 时，当前 __wseq 值被保存为新的 __g1_start
                __value32 = {
                    __low = 0,
                    __high = 0
                }
            },
            __g_refs = {0, 0},      //组引用计数(2的倍数，一个线程对应2)
            __g_size = {0, 0},      //组大小，
            __g1_orig_size = 0,
            __wrefs = 0,            //等待计数 （8的倍数，一个线程对应8,低3位被使用）
            __g_signals = {0, 0}    //可被消费的信号计数
        },
        __size = {0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000', 0 '\000'},
        __align = 0
    }

    组：
        作用：高效管理等待线程和实现 pthread_cond_broadcast() 操作，g1和g2交替切换
        组成：
            g1:当前正在等待的线程集合
            g2:管理新到来的等待线程或者在广播操作期间的组
        过程：
            正常等待流程
                线程调用 pthread_cond_wait(),获取__wseq用于确定等待队列位置
                序列号 < __g1_start 的线程属于「g1待处理组」，序列号 ≥ __g1_start 的线程属于「g2当前活跃组」或将被分配到新组
                相应组的 __g_size 增加
                线程进入等待状态
            广播流程
                调用 pthread_cond_broadcast() __g1_start=最后一次wait操作的__wseq
                g1组的__g_signals 相应增加，广播g1组
                切换g1和g2,__g1_start=最后一次wait操作的__wseq

            信号处理流程
                等待线程被唤醒
                相应组的 __g_refs 减少
                当组的 __g_refs 归零时，表示该组的所有线程都已处理完信号